1.矩阵乘法的CUDA实现中如何分块，线程是如何组织的？


2.链表转置
查看Data struct分支


3.内存、L1 cache、L2 cache的延迟如何测试



4.C++的的多态
其实就是方便类继承机制中能够在父类和子类中定义相同的成员函数，同时还能够控制调用的父类定义还子类定义的



5.查找N个数中最大值和最小值的方法（比较次数小于2N）
//每个元素都和max和min对比，总共对比次数为2（n-1）
void search_max_min(int a[], int n)
{
    int max=a[0];
    int min=a[0];
    for(int i = 1; i<n;i++)
    {
        if(a[i]>max)
            max = a[i];
        if(a[i]<min)
            min = a[i];
     }
}

//每个元素先和max比较，如果大于max那就没有必要和min比较了，从而减少比较次数，最坏情况2（n-1）次，最好是n次
void search_max_min(int a[], int n)
{
    int max=a[0];
    int min=a[0];
    for(int i = 1; i<n;i++)
    {
        if(a[i]>max)
            max = a[i];
        else
        {
            if(a[i]<min)
                min = a[i];
        }
     }
}

//两两组队，左小右大，然后再小的里面找最小，大的里面找最大,3n/2-1
void search_max_min(int a[], int n)
{   
    //比较n/2次
    for(int = 0;i<n/2;i++)
    {
        int temp;
        if(a[2*i]>a[2*i+1])
        {
            temp = a[2*i+1];
            a[2*i+1] = a[2*i];
            a[2*i] = a[2*i+1];
        }
     }
     //比较n/2-1次
     int min = a[0];
     for(int = 1;i<n/2;i++)
     {
        if(min>a[2*i])
        {
            min = a[2*i];
        }
     }
     
     int max = a[0];
     for(int = 1;i<n/2;i++)
     {
        if(max<a[2*i+1])
        {
            max = a[2*i+1];
        }
     }
     




6.编译器、汇编器、链接器
(1).预处理(cpp)：预处理器不止一种，而C/C++的预处理器就是其中最低端的一种——词法预处理器，主要是进行文本替换、宏展开、删除注释这类简单工作。

gcc -E 选项可以得到预处理后的结果，扩展名为.i；
C/C++预处理不做任何语法检查，不仅是因为它不具备语法检查功能，也因为预处理命令不属于C/C++语句（这也是定义宏时不要加分号的原因），语法检查是编译器
要做的事情；
预处理之后，得到的仅仅是真正的源代码；
GCC确实很强大，如果是用VC这种IDE，恐怕就不能看到预处理后的结果。
(2).编译器(ccl)：将文本文件.i翻译成文本文件.s，得到汇编语言程序(把高级语言翻译为机器语言)，该种语言程序中的每条语句都以一种标准的文本格式
确切的描述了一条低级机器语言指令。

gcc -S 选项可以得到编译后的汇编代码，扩展名为.s；
汇编语言为不同高级语言的不同编译器提供了通用的输出语言，比如，C编译器和Fortran编译器产生的输出文件用的都是一样的汇编语言。
(3).汇编(as)：将.s翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序的格式，并将结果保存在目标文件.o中(把汇编语言翻译成机器语言的过程)。

gcc -c 选项可以得到汇编后的结果，扩展名为.o；
.o是一个二进制文件，它的字节编码是机器语言指令而不是字符。如果在文本编辑器中打开.o文件，看到的将是一堆乱码。
把一个源程序翻译成目标程序的工作过程分为五个阶段：词法分析；语法分析；语义检查和中间代码生成；代码优化；目标代码生成。主要是进行词法分析和语法分析，又称为源程序分析，分析过程中发现有语法错误，给出提示信息。
(4).链接(ld)：gcc会到系统默认的搜索路径”/usr/lib”下进行查找，也就是链接到libc.so.6库函数中去。 函数库一般分为静态库和动态库两种。静态库是指编译链接时，把库文件的代码全部加入到可执行文件中，因此生成的文件比较大，但在运行时也就不再需要库文件了。其后缀名一般为”.a”。动态库与之相反，在编译链接时并没有把库文件的代码加入到可执行文件中，而是在程序执行时由运行时链接文件加载库，这样可以节省系统的开销。动态库一般后缀名为”.so”，如前面所述的libc.so.6就是动态库。gcc在编译时默认使用动态库。
